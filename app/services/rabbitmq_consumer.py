import asyncio
import json
import logging
from typing import Dict, Any
import aio_pika
from aio_pika import Message, ExchangeType
import os

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class RabbitMQConsumer:
    def __init__(self):
        self.connection = None
        self.channel = None
        self.exchange = None

        # RabbitMQ configuration - should match Spring Boot config
        self.rabbitmq_url = f"amqp://{os.getenv('RABBITMQ_USER', 'scholar')}:{os.getenv('RABBITMQ_PASSWORD', 'scholar123')}@{os.getenv('RABBITMQ_HOST', 'localhost')}:{os.getenv('RABBITMQ_PORT', '5672')}/"
        self.exchange_name = "scholarai.exchange"
        self.summarization_queue = "scholarai.summarization.queue"
        self.summarization_completed_routing_key = "scholarai.summarization.completed"

    async def connect(self):
        """Establish connection to RabbitMQ"""
        try:
            self.connection = await aio_pika.connect_robust(self.rabbitmq_url)
            self.channel = await self.connection.channel()

            # Declare exchange
            self.exchange = await self.channel.declare_exchange(
                self.exchange_name, ExchangeType.TOPIC, durable=True
            )

            # Declare queue for consuming summarization requests
            queue = await self.channel.declare_queue(
                self.summarization_queue, durable=True
            )

            # Bind queue to exchange
            await queue.bind(self.exchange, "scholarai.summarization")

            logger.info("üîó Connected to RabbitMQ successfully")
            return queue

        except Exception as e:
            logger.error(f"‚ùå Failed to connect to RabbitMQ: {e}")
            raise

    async def process_summarization_request(self, message: aio_pika.IncomingMessage):
        """Process a summarization request with simulated delay"""
        async with message.process():
            try:
                # Parse the message
                body = json.loads(message.body.decode())
                logger.info(f"üì• Received summarization request: {body}")

                paper_id = body.get("paperId")
                pdf_url = body.get("pdfUrl")
                correlation_id = body.get("correlationId")

                logger.info(f"üîÑ Processing paper {paper_id} from {pdf_url}")

                # Simulate AI processing with delay (10-15 seconds)
                processing_time = 12  # You can randomize this between 10-15
                logger.info(
                    f"‚è≥ Simulating AI processing for {processing_time} seconds..."
                )
                await asyncio.sleep(processing_time)

                # Generate a mock summary
                mock_summary = f"""
                This is a simulated summary for paper {paper_id}.
                
                Key findings:
                - The research presents novel approaches to the problem domain
                - Methodology shows significant improvements over baseline methods
                - Results demonstrate statistical significance with p < 0.05
                - The work contributes to advancing the field through innovative techniques
                
                Limitations:
                - Sample size could be larger for better generalization
                - Some edge cases require further investigation
                
                Future work suggestions:
                - Extend the methodology to handle larger datasets
                - Investigate cross-domain applications
                
                This summary was generated by ScholarAI FastAPI service.
                Processing completed at {asyncio.get_event_loop().time()}.
                """

                # Send completion event back to Spring Boot
                await self.send_completion_event(paper_id, mock_summary, correlation_id)

                logger.info(
                    f"‚úÖ Successfully processed summarization for paper {paper_id}"
                )

            except Exception as e:
                logger.error(f"‚ùå Error processing summarization request: {e}")
                # In production, you might want to send an error event back

    async def send_completion_event(
        self, paper_id: str, summary_text: str, correlation_id: str
    ):
        """Send completion event back to Spring Boot"""
        try:
            completion_event = {
                "paperId": paper_id,
                "summaryText": summary_text,
                "correlationId": correlation_id,
            }

            message = Message(
                json.dumps(completion_event).encode(), content_type="application/json"
            )

            await self.exchange.publish(
                message, routing_key=self.summarization_completed_routing_key
            )

            logger.info(f"üì§ Sent completion event for paper {paper_id}")

        except Exception as e:
            logger.error(f"‚ùå Failed to send completion event: {e}")

    async def start_consuming(self):
        """Start consuming messages from the queue"""
        try:
            queue = await self.connect()

            # Set up consumer
            await queue.consume(self.process_summarization_request)

            logger.info("üéØ FastAPI RabbitMQ Consumer started. Waiting for messages...")
            logger.info("üìã Listening on queue: scholarai.summarization.queue")
            logger.info("üîÑ Will send results to: scholarai.summarization.completed")

            # Keep the consumer running
            await asyncio.Future()  # Run forever

        except Exception as e:
            logger.error(f"‚ùå Error in consumer: {e}")
            raise

    async def close(self):
        """Close the connection"""
        if self.connection:
            await self.connection.close()
            logger.info("üîå RabbitMQ connection closed")


# Global consumer instance
consumer = RabbitMQConsumer()
